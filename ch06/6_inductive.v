Require Export ZArith List Arith Bool.

Inductive month : Set
  := January | February | March | April | May | June
     | July | August | September | October | November | December.

(* Exercise 6.1
   Define an inductive type for seasons and then use the function
   [month_rec] to define a function that maps every month to the season that
   contains most of its days. *)
Inductive season : Set := Winter | Spring | Summer | Fall.

Check season_rec.
(* season_rec : forall P : season -> Set,
   P Winter -> P Spring -> P Summer -> P Fall
   -> forall s : season, P s *)

Definition is_winter : season -> bool.
  intro s. apply season_rec.
  - (* Winter *) exact true.
  - (* Spring *) exact false.
  - (* Summer *) exact false.
  - (* Fall   *) exact false.
  - exact s.
Defined.

Print is_winter.
(* is_winter : season -> bool
   := fun s : season
      => season_rec (fun _ : season => bool) true false false false s *)

Compute (is_winter Winter). (* = true : bool *)
Compute (is_winter Fall). (* = false : bool *)

Definition season_of_month : month -> season
  := month_rec (fun _ : month => season)
               Winter Winter
               Spring Spring Spring
               Summer Summer Summer
               Fall Fall Fall
               Winter.

Compute (season_of_month December). (* = Winter : season *)
Compute (season_of_month July). (* = Summer : season *)

(* Exercise 6.2
   What are the types of [bool_ind] and [bool_rec] that are
   generated by the Coq system for the type bool? *)
Check bool_ind.
(* bool_ind : forall P : bool -> Prop,
     P true -> P false -> forall b : bool, P b *)

(* 6.1.2 Simple Reasoning and Computing *)
Theorem month_equal (m : month)
 : m=January \/ m=February \/ m=March \/ m=April \/ m=May \/ m=June
   \/ m=July \/ m=August \/  m=September \/ m=October \/ m=November
   \/ m=December.
Proof. destruct m; auto 12. Qed.

(** explicit use of month_ind: *)
Theorem month_equal' (m : month)
 : m=January \/ m=February \/ m=March \/ m=April
   \/ m=May \/ m=June \/ m=July \/ m=August
   \/ m=September \/ m=October \/ m=November \/ m=December.
Proof. pattern m. apply month_ind; auto 12. Qed.

(* Exercise 6.3 Prove in two different ways the following theorem:
   1. Give directly a proof term, with occurences of
      bool_ind, or_introl, or_intror and refl_equal.
   2. Use the following tactics :
      pattern, apply, left, right, and reflexivity. *)
Theorem bool_cases (b : bool) : b = true \/ b = false.
Proof.
  exact (bool_ind (fun c => c = true \/ c = false)
                  (or_introl eq_refl)
                  (or_intror eq_refl) b).
Qed.

Theorem bool_cases' (b : bool) : b = true \/ b = false.
Proof. pattern b. apply bool_ind; [left | right]; reflexivity. Qed.

Theorem bool_cases'' (b : bool) : b = true \/ b = false.
Proof. destruct b; [left | right]; reflexivity. Qed.

(* 6.1.4 Pattern Matching *)
Check (fun b : bool => match b with false => 45 | true => 33 end).
(* fun b : bool => if b then 33 else 45 : bool -> nat *)

Definition month_length (leap : bool) (m : month) : nat
  := match m with
     | January => 31 | February => if leap then 29 else 28
     | March => 31   | April => 30    | May => 31  | June => 30
     | July => 31    | August => 31   | September => 30
     | October => 31 | November => 30 | December => 31
     end.

Definition month_length' (leap : bool)
  := month_rec (fun _ : month => nat)
               31 (if leap then 29 else 28)
               31 30 31 30 31 31 30 31 30 31.

Definition month_length'' (leap : bool) (m : month)
  := match m with
     | February => if leap then 29 else 28
     | April  | June  | September | November => 30
     | _  => 31
     end.

Example month_length_eq1 : month_length = month_length'.
Proof. reflexivity. Qed.

Example month_length_eq2 : month_length = month_length''.
Proof. reflexivity. Qed.

Eval compute in (fun leap => month_length leap November).
(* = fun _ : bool => 30 : bool -> nat *)

Example length_february : month_length false February = 28.
Proof. reflexivity. Qed.

(* Exercise 6.4
   Using the type introduced for seasons in Exercise 6.1 page 139,
   write the function that maps any month to the season
   that contains most of its days, this time
   using the pattern matching construct. *)

Definition season_of_month' (m : month) : season
  := match m with
     | December | January | February => Winter
     | March | April | May => Spring
     | June | July | August => Summer
     | September | October | November => Fall
     end.

Example season_of_month_eq : season_of_month = season_of_month'.
Proof. reflexivity. Qed.

(* Exercise 6.5
   Write the function that maps every month that has an even
   number of days to the boolean value true and the others to false. *)
Definition is_even_days_in_month (leap : bool) (m : month)
  := Nat.even (month_length leap m).

(* Exercise 6.6
   Define the functions associated with the following boolean connectives:
   Notice that these functions are already defined in the standard library
   under the names negb, orb, andb, xorb and Bool.eqb. *)
Definition bool_not (b : bool) : bool := if b then false else true.
Definition bool_or (a b : bool) : bool
  := if a then true else
       if b then true else false.
Definition bool_and (a b : bool) : bool := if a then b else false.
Definition bool_xor (a b : bool) : bool
  := if a then bool_not b else b.
Definition bool_eq (a b : bool) : bool
  := if a then b else bool_not b.

(* Prove the following theorems: *)
Theorem bool_xor_not_eq (b1 b2 : bool)
  : bool_xor b1 b2 = bool_not (bool_eq b1 b2).
Proof. destruct b1, b2; reflexivity. Qed.

Theorem bool_not_and (b1 b2 : bool)
  : bool_not (bool_and b1 b2) = bool_or (bool_not b1) (bool_not b2).
Proof. destruct b1, b2; reflexivity. Qed.

Theorem bool_not_not (b : bool) : bool_not (bool_not b) = b.
Proof. destruct b; reflexivity. Qed.

Theorem bool_tex (b : bool) : bool_or b (bool_not b) = true.
Proof. destruct b; reflexivity. Qed.

Theorem bool_eq_reflect (b1 b2 : bool) : bool_eq b1 b2 = true -> b1 = b2.
Proof.
  destruct b1, b2; simpl; intro H;
    try rewrite H; reflexivity.
Qed.

Theorem bool_eq_reflect2 (b1 b2 : bool) : b1 = b2 -> bool_eq b1 b2 = true.
Proof. intro H. subst b2. destruct b1; reflexivity. Qed.

Theorem bool_not_or (b1 b2 : bool)
  : bool_not (bool_or b1 b2) = bool_and (bool_not b1) (bool_not b2).
Proof. destruct b1, b2; reflexivity. Qed.

Theorem bool_or_and_distr (b1 b2 b3 : bool)
  : bool_or (bool_and b1 b3) (bool_and b2 b3) = bool_and (bool_or b1 b2) b3.
Proof. destruct b1, b2, b3; reflexivity. Qed.

(* 6.1.5 Record Types *)
Open Scope Z_scope.

Inductive plane : Set := point : Z -> Z -> plane.
(*
plane is defined
plane_rect is defined
plane_ind is defined
plane_rec is defined
plane_sind is defined
*)

Check point. (* point : Z -> Z -> plane *)
Check plane_ind.
(* plane_ind : forall P : plane -> Prop,
   (forall z z0 : Z, P (point z z0)) -> forall p : plane, P p *)

Definition abscissa (p : plane) : Z
  := match p with point x y => x end.
Check abscissa. (* abscissa : plane -> Z *)

Reset plane. (* also reset [abscissa] *)

Record plane : Set := point {abscissa : Z; ordinate : Z}.
(*
plane is defined
abscissa is defined
ordinate is defined
*)
Print plane.
(* Record plane : Set := point { abscissa : Z;  ordinate : Z } *)
Check point. (* point : Z -> Z -> plane *)
Check abscissa. (* abscissa : plane -> Z *)
Print abscissa.
(* abscissa : plane -> Z
   := fun p : plane => let (abscissa, _) := p in abscissa *)

(* Exercise 6.7 What is the type of plane_rec? *)
(* Check plane_rec. *)
(* Error: The reference plane_rec was not found in the current environment. *)

(* Exercise 6.8
   Define a function that computes the "Manhattan" distance for
   points of the plane (the Manhattan distance
   is the sum of the absolute values of differences of coordinates). *)
Definition manhattan_distance (p1 p2 : plane) : Z
  := let (x1, y1) := p1 in
     let (x2, y2) := p2 in
     Z.abs (x1 - x2) + Z.abs (y1 - y2).

Check (point 1 2).
Check (point 1 (-2)).

Example manhattan_distance_ex
  : manhattan_distance (point (-1) (-2)) (point 4 2) = 9.
Proof. reflexivity. Qed.

(* 6.1.6 Records with Variants *)
Inductive vehicle : Set
  := bicycle (* [number of seats] *) : nat -> vehicle
   | motorized (* [number of seats, number of wheels] *)
     : nat -> nat -> vehicle.

Check vehicle_ind.
(* vehicle_ind : forall P : vehicle -> Prop,
   (forall n : nat, P (bicycle n)) ->
   (forall n n0 : nat, P (motorized n n0)) -> forall v : vehicle, P v *)

Definition nb_seats (v : vehicle) : nat
  := match v with
     | bicycle n => n
     | motorized n _ => n
     end.

Definition nb_wheels (v : vehicle) : nat
  := match v with
     | bicycle _ => 2
     | motorized _ m => m
     end.

(* Exercise 6.9
   What is the type of [vehicle_rec]? Use this function to define
   an equivalent to [nb_seats]. *)
Check vehicle_rec.
(* vehicle_rec : forall P : vehicle -> Set,
   (forall n : nat, P (bicycle n)) ->
   (forall n n0 : nat, P (motorized n n0)) -> forall v : vehicle, P v *)

Definition nb_seats' : vehicle -> nat
  := vehicle_rec (fun _ : vehicle => nat)
                 (fun n => n)
                 (fun n _ => n).

Example nb_seats_eq : nb_seats = nb_seats'.
Proof. reflexivity. Qed.

(* 6.2 Case-Based Reasoning *)
Open Scope nat_scope.
Theorem at_least_28 (leap : bool) (m : month)
  : 28 <= month_length leap m.
Proof. case m, leap; simpl; auto with arith. Qed.

Theorem at_least_28' (leap : bool) (m : month)
  : 28 <= month_length leap m.
Proof.
  case m, leap; simpl;
    repeat ( try apply le_n; apply le_S ).
Qed.

Print at_least_28.
(* at_least_28 : forall (leap : bool) (m : month), 28 <= month_length leap m
  := fun (leap : bool) (m : month) =>
       match m as m0 return (28 <= month_length leap m0) with
       | January =>
         if leap as b return (28 <= month_length b January)
         then le_S 28 30 (le_S 28 29 (le_S 28 28 (le_n 28)))
         else le_S 28 30 (le_S 28 29 (le_S 28 28 (le_n 28)))
       | February =>
         if leap as b return (28 <= month_length b February)
         then le_S 28 28 (le_n 28)
         else le_n 28
       ...
       end. *)

(* 6.2.2.1 The discriminate Tactic *)
Definition next_month (m : month)
  := match m with
     | January => February  | February => March | March => April
     | April => May         | May => June       | June => July
     | July => August       | August => September
     | September => October | October => November
     | November => December | December => January
     end.

Theorem next_august_then_july (m : month) : next_month m = August -> m = July.
Proof.
  case m; simpl; intros H;
    (reflexivity || discriminate H).
Qed.

(* 6.2.2.2 ** The Inner Workings of discriminate *)
Theorem not_January_eq_February : January <> February.
Proof. discriminate. Qed.

(* not using [discriminate] *)
Theorem not_January_eq_February' : January <> February.
Proof.
  unfold not. intros H.
  change ((fun m : month
           => match m with | January => True | _ => False end)
            February).
  now rewrite <- H.
Qed.

(* not using [change], [rewrite] and [reflexivity] *)
Theorem not_January_eq_February'' : January <> February.
Proof.
  unfold not. intros H.
  pose (f := (fun m : month
              => match m with
                 | January => True
                 | _ => False end)).
  apply (eq_ind (f February) (fun P => P)).
  - apply (eq_ind January f).
    + unfold f. apply I.
    + exact H.
  - unfold f. apply eq_refl.
Qed.

(* Exercise 6.10
   Define a function [is_January] that maps [January] to [True]
   and any other month to [False], using the function [month_rect]. *)
Definition is_January' (m : month) : Prop
  := match m with
     | January => True
     | _ => False
     end.

Definition is_January : month -> Prop
  := month_rect (fun _ => Prop)
                True
                False False False False False False False False
                False False False.

Example is_January_eq : is_January = is_January'.
Proof. reflexivity. Qed.

(* Try to automate applying [month_rect (fun _ => Prop) True]
   to [False] 11 times *)
Definition add_arg_type (A B : Type) : Type := A -> B.
Compute ((add_arg_type Prop) ((add_arg_type Prop) nat)).
(* = Prop -> Prop -> nat : Type *)

Fixpoint iterate (A : Type) (f : A -> A) (n : nat) (a : A) : A
  := match n with
     | O => a
     | S n' => iterate A f n' (f a)
     end.
Compute (iterate nat S 3 O). (* = 3 : nat *)
Compute (iterate Type (add_arg_type Prop) 3 nat).
(* = Prop -> Prop -> Prop -> nat : Type *)

Definition add_n_arg_types (A B : Type) (n : nat) : Type
  := (iterate Type (add_arg_type A) n B).
Compute (add_n_arg_types Prop nat 3).
(* = Prop -> Prop -> Prop -> nat : Type *)
Compute (add_n_arg_types Prop nat 0). (* = nat : Type *)

(* TODO Attempt failed *)
(* Fixpoint repeat_arg (A B : Type) (a : A)
         (n : nat) (f : add_n_arg_types A B n) : B
  := match n with
     | O => f (* The term "f" has type "add_n_arg_types A B n"
                 while it is expected to have type "B". *)
     | S n' => repeat_arg A B a n' (f a)
     end. *)

(* Fixpoint repeat_arg (A B : Type) (a : A)
         (n : nat) (f : add_n_arg_types A B n) : B
  := match n
           return (match n with
                   | O => add_n_arg_types A B n
                   | S n' => add_n_arg_types A B n'
                   end)
     with
     | O => f (* The term "f" has type "add_n_arg_types A B n"
                 while it is expected to have type "add_n_arg_types A B 0". *)
     | S n' => repeat_arg A B a n' (f a)
     end. *)

(* Exercise 6.11 *
   Use the same technique to build a proof of [true <> false]. *)
Theorem true_is_not_false : true <> false.
Proof. discriminate. Qed.

Theorem true_is_not_false' : true <> false.
Proof.
  intro H.
  change ((fun b : bool => if b then True else False) false).
  now rewrite <- H.
Qed.

(* Exercise 6.12
   For the [vehicle] type (see Sect. 6.1.6), use the same technique
   to build a proof that no [bicycle] is equal to a [motorized] vehicle. *)
Theorem bicycle_is_not_motorized (n m : nat) : bicycle n <> motorized n m.
Proof. discriminate. Qed.

Theorem bicycle_is_not_motorized' (n m : nat) : bicycle n <> motorized n m.
Proof.
  intro H.
  change ((fun v : vehicle
           => match v with
              | bicycle _ => False
              | motorized _ _ => True
              end) (bicycle n)).
  now rewrite H.
Qed.

(* 6.2.3 Injective Constructors *)
Theorem bicycle_eq_seats (x1 y1 : nat) : bicycle x1 = bicycle y1 -> x1 = y1.
Proof. intro H. now injection H. Qed.

(* Simulating injection (for the fun) *)
Theorem bicycle_eq_seats' (x1 y1 : nat) : bicycle x1 = bicycle y1 -> x1 = y1.
Proof.
 intro H.
 change (nb_seats (bicycle x1) = nb_seats (bicycle y1)).
 rewrite H. reflexivity.
Qed.

(* use more primitive tactics *)
Theorem bicycle_eq_seats'' (x1 y1 : nat) : bicycle x1 = bicycle y1 -> x1 = y1.
Proof.
 intro H.
 apply (eq_ind (bicycle x1)
               (fun v : vehicle => nb_seats (bicycle x1) = nb_seats v)
               (eq_refl (nb_seats (bicycle x1)))
               (bicycle y1) H).
Qed.

Section injection_example.
  Variables A B : Set.
  Inductive T : Set := c1 : A -> T | c2 : B -> T.

  Theorem inject_c2 (x y : B) : c2 x = c2 y -> x = y.
  Proof using. intro H. now injection H. Qed.

  Theorem inject_c2' (x y : B) : c2 x = c2 y -> x = y.
  Proof using.
    intro H.
    pose (fun t : T => match t with | c1 a => x | c2 b => b end) as f.
    change (f (c2 x) = f (c2 y)).
    rewrite H. reflexivity.
  Qed.
End injection_example.

(* 6.2.4 Inductive Types and Equality *)

(* Exercise 6.13 **
   This exercise shows a use of discriminate and underlines
   the danger of adding axioms to the system.
   The ''theory'' introduced here proposes a description of rational numbers
   as fractions with a non-zero denominator. An axiom is added to
   indicate that two rational numbers are equal as soon
   as they satisfy a classical arithmetic condition. *)

Require Import Arith.

Record RatPlus : Set
  := mkRat {top : nat; bottom : nat; bottom_condition : bottom <> 0}.

Axiom eq_RatPlus : forall r1 r2 : RatPlus,
    top r1 * bottom r2 = top r2 * bottom r1 -> r1 = r2.

Theorem eq_RatPlus_imp_False : False.
Proof.
  pose (mkRat 1 1 (Nat.neq_succ_0 _)) as r1.
  pose (mkRat 2 2 (Nat.neq_succ_0 _)) as r2.
  assert (r1 = r2) as eq.
  { apply eq_RatPlus. reflexivity. }
  discriminate eq.
Qed.

Reset RatPlus.

(* 6.2.5 * Guidelines for the case Tactic *)
(* solution from authors *)
Theorem next_march_shorter (leap : bool) (m1 m2 : month)
  : next_month m1 = March
    -> month_length leap m1 <= month_length leap m2.
Proof.
  intros H.
  case_eq m1; intro eq; rewrite eq in H; simpl in H;
    try discriminate H.
  case leap, m2; simpl; auto with arith.
Qed.

(* my solution using destruct *)
Theorem next_march_shorter1 (leap : bool) (m1 m2 : month)
  : next_month m1 = March
    -> month_length leap m1 <= month_length leap m2.
Proof.
  intros H. destruct m1; simpl in H; try discriminate H.
  destruct leap, m2; simpl; auto with arith.
Qed.

(* my solution using [case] with delaying [into] *)
Theorem next_march_shorter2 (leap : bool) (m1 m2 : month)
  : next_month m1 = March
    -> month_length leap m1 <= month_length leap m2.
Proof.
  case m1; simpl; intro H; try discriminate H.
  case leap, m2; simpl; auto with arith.
Qed.

(* use generalize *)
Theorem next_march_shorter3 (leap : bool) (m1 m2 : month)
  : next_month m1 = March
    -> month_length leap m1 <= month_length leap m2.
Proof.
  intro H. generalize H. clear H.
  case m1; simpl; intros H; try discriminate H.
  case leap, m2; simpl; auto with arith.
Qed.

(* introduce equality *)
Theorem next_march_shorter4 (leap : bool) (m1 m2 : month)
  : next_month m1 = March
    -> month_length leap m1 <= month_length leap m2.
Proof.
  intro H. generalize (eq_refl m1). pattern m1 at -1.
  case m1; intro eq; rewrite eq in H; simpl in H;
    try discriminate H.
  case leap, m2; simpl; auto with arith.
Qed.

(* how to define own case_eq tactic *)
Ltac caseEq f := generalize (refl_equal f); pattern f at -1; case f.

(* test it *)
Theorem next_march_shorter5 (leap : bool) (m1 m2 : month)
  : next_month m1 = March
    -> month_length leap m1 <= month_length leap m2.
Proof.
  intros H.
  caseEq m1; intro eq; rewrite eq in H; simpl in H;
    try discriminate H.
  case leap, m2; simpl; auto with arith.
Qed.

(* New exercise - On partial functions
 Complete the following development: *)
Section partial_functions.
  Variable P : nat -> Prop.
  Variable f : nat -> option nat.

  Hypothesis f_domain : forall n, P n <-> f n <> None.

  Definition g n : option nat
    := match f (n + 2) with
       | None => None
       | Some y => Some (y + 2)
       end.

  Lemma g_domain : forall n, P (n + 2) <-> g n <> None.
  Proof using f_domain.
    intro n. unfold g. split; intro H.
    - cut (f (n + 2) <> None).
      + intro H'.
        destruct (f (n + 2)) eqn:eq; [discriminate | assumption].
      + apply f_domain, H.
    - apply f_domain.
      destruct (f (n + 2)) eqn:eq; [discriminate | assumption].
  Qed.

End partial_functions.

(* 6.3 Recursive Types *)
Print nat. (* Inductive nat : Set :=  O : nat | S : nat -> nat *)
Check plus. (* Init.Nat.add : nat -> nat -> nat *)
Check plus_O_n. (* plus_O_n : forall n : nat, 0 + n = n *)
Check plus_Sn_m. (* plus_Sn_m : forall n m : nat, S n + m = S (n + m) *)

(* A first, detailed, proof of associativity of + *)
(* authors' solution *)
Theorem plus_assoc (x y z : nat) : (x + y) + z = x + (y + z).
Proof.
  induction x as [| x0 IH].
  - simpl. reflexivity.
  - simpl. rewrite IH. reflexivity.
Qed.

(* my variation *)
Theorem plus_assoc' (x y z : nat) : (x + y) + z = x + (y + z).
Proof.
  induction x as [| x' IH]; simpl; [| rewrite IH]; reflexivity.
Qed.

Theorem plus_assoc'' (x y z : nat) : (x + y) + z = x + (y + z).
Proof.
  pattern x.
  apply nat_ind; simpl; [| intros x' IH; rewrite IH]; reflexivity.
Qed.

Theorem plus_n_O (n : nat) : n + 0 = n.
Proof.
  induction n as [| p IH]; try reflexivity.
  simpl. rewrite IH. reflexivity.
Qed.

Theorem plus_n_Sm (n m : nat) : n + (S m) = S (n + m).
Proof.
  induction n as [| p IH]; try reflexivity.
  simpl. rewrite IH. reflexivity.
Qed.

Theorem plus_comm (n m : nat) : n + m = m + n.
Proof.
  induction n as [| p IH].
  - rewrite plus_n_O. reflexivity.
  - simpl. rewrite IH, plus_n_Sm. reflexivity.
Qed.

(* 6.3.3 Recursive Programming *)
Fixpoint mult2 (n : nat) : nat
  := match n with
     | 0 => 0
     | S p => S (S (mult2 p))
     end.

Reset iterate.
Fixpoint iterate {A : Type} (f : A -> A) (n : nat) (x : A) {struct n} : A
  := match n with
     | O => x
     | S p => f (iterate f p x)
     end.

(* Tail call *)
Fixpoint iterate' {A : Type} (f : A -> A) (n : nat) (x : A) {struct n} : A
  := match n with
     | O => x
     | S p => iterate' f p (f x)
     end.

Theorem iterate'_step {A : Type} (f : A -> A) (n : nat) (x : A)
  : iterate' f n (f x) = f (iterate' f n x).
Proof.
  generalize dependent x.
  induction n as [| p IH]; try reflexivity.
  simpl. intro x. apply IH.
Qed.

Theorem iterate_eq {A : Type} (f : A -> A) (n : nat) (x : A)
  : iterate f n x = iterate' f n x.
Proof.
  induction n as [| p IH]; try reflexivity.
  simpl. rewrite IH, iterate'_step. reflexivity.
Qed.

(* Exercise 6.14
   Reproduce the above discussion for the function mult:
   compile a table describing convertibility
   for simple patterns of the two arguments. *)
Example mult_O_O : 0 * 0 = 0.
Proof. reflexivity. Qed.

Example mult_O_m (m : nat) : 0 * m = 0.
Proof. reflexivity. Qed.

Example mult_Sn_m (n m : nat) : (S n) * m = m + n * m.
Proof. reflexivity. Qed.

Theorem mult_n_O (n : nat) : n * 0 = 0.
Proof.
  induction n as [| p IH]; try reflexivity.
  simpl. assumption.
Qed.

Example mult_n_Sm (n m : nat) : n * (S m) = n + n * m.
Proof.
  induction n as [| p IH]; try reflexivity.
  simpl. rewrite IH. apply eq_S.
  repeat rewrite plus_assoc.
  pattern (m + p). rewrite plus_comm. reflexivity.
Qed.

Theorem mult_comm (n m : nat) : n * m = m * n.
Proof.
  induction n as [| p IH].
  - rewrite mult_n_O. reflexivity.
  - simpl. rewrite IH, mult_n_Sm. reflexivity.
Qed.

(* Exercise 6.15
   Define a function of type [nat -> bool] that only returns [true]
   for numbers smaller than 3, in other terms [S (S (S 0))] *)
Definition smaller_than_three (n : nat) : bool
  := match n with
     | O | S O | S (S O) => true
     | _ => false
     end.

Example zero_is_smaller_than_three : smaller_than_three 0 = true.
Proof. reflexivity. Qed.

Example two_is_smaller_than_three : smaller_than_three 2 = true.
Proof. reflexivity. Qed.

Example three_is_not_smaller_than_three : smaller_than_three 3 = false.
Proof. reflexivity. Qed.

Example fourty_five_is_not_smaller_than_three
  : smaller_than_three 45 = false.
Proof. reflexivity. Qed.

Fixpoint smaller_than (n m : nat) : bool
  := match n, m with
     | O, O => false
     | O, S _ => true
     | S _, O => false
     | S n', S m' => smaller_than n' m'
     end.

Theorem smaller_than_is_ltb (n m : nat) : smaller_than n m = (n <? m).
Proof.
  generalize dependent m.
  induction n as [| n' IHn]; intro m.
  - destruct m as [| m']; reflexivity.
  - destruct m as [| m']; try reflexivity.
    simpl. rewrite IHn.
    destruct (n' <? m') eqn:H; symmetry.
    + apply Nat.ltb_lt, lt_n_S, Nat.ltb_lt, H.
    + apply Nat.ltb_nlt in H. apply Nat.ltb_nlt.
      intro H'. apply H, lt_S_n, H'.
Qed.

Definition smaller_than_three' (n : nat) : bool := smaller_than n 3.

Theorem smaller_than_three_eq (n : nat)
  : smaller_than_three n = smaller_than_three' n.
Proof.
  unfold smaller_than_three'.
  destruct n as [| [| [| [| p]]]]; reflexivity.
Qed.

(* Exercise 6.16
   Define an addition function so that the principal argument is
   second instead of first argument. *)
Fixpoint left_add (n m : nat) {struct m} : nat
  := match m with
     | O => n
     | S p => S (left_add n p)
     end.

Theorem left_add_correct (n m : nat) : left_add n m = n + m.
Proof.
  induction m as [| p IH].
  - rewrite <- plus_n_O. reflexivity.
  - rewrite <- plus_n_Sm. simpl.
    rewrite IH. reflexivity.
Qed.

(* Exercise 6.17
   Define a function [sum_f] that takes as arguments a number [n]
   and a function [f] of type [nat -> Z] and returns the sum of
   all values of [f] for the natural numbers
   that are strictly smaller than [n] *)
Fixpoint sum_f (n : nat) (f : nat -> Z) {struct n} : Z
  := match n with
     | O => 0
     | S p => (f p) + sum_f p f
     end.

Example sum_id1 : sum_f 1 Z.of_nat = 0%Z.
Proof. reflexivity. Qed.

Example sum_id3 : sum_f 3 Z.of_nat = 3%Z.
Proof. reflexivity. Qed.

Example sum_id4 : sum_f 4 Z.of_nat = 6%Z.
Proof. reflexivity. Qed.

Require Import Program.Basics.

Example sum_S4 : sum_f 4 (compose Z.of_nat S) = 10%Z.
Proof. reflexivity. Qed.

(* Exercise 6.18
   Define [two_power : nat -> nat] so that [two_power n] is [2^n]. *)
Definition two_power (n : nat) : nat := iterate (Nat.mul 2) n 1.

Example two_power0 : two_power 0 = 1.
Proof. reflexivity. Qed.

Example two_power1 : two_power 1 = 2.
Proof. reflexivity. Qed.

Example two_power3 : two_power 3 = 8.
Proof. reflexivity. Qed.

Fixpoint two_power' (n : nat) : nat
  := match n with
     | O => 1
     | S p => 2 * two_power' p
     end.

Lemma two_power_Sn (n : nat) : two_power (S n) = 2 * two_power n.
Proof. reflexivity. Qed.

Theorem two_power_eq (n : nat) : two_power n = two_power' n.
Proof.
  induction n as [| p IH]; try reflexivity.
  rewrite two_power_Sn. simpl. now rewrite ?IH.
Qed.

(* 6.3.4 Variations in the Form of Constructors *)
Inductive Z_btree : Set
  := Z_leaf : Z_btree
   | Z_bnode : Z -> Z_btree -> Z_btree -> Z_btree.

Check Z_btree_ind.
(* Z_btree_ind : forall P : Z_btree -> Prop,
   P Z_leaf
   -> (forall (z : Z) (z0 : Z_btree), P z0
      -> forall z1 : Z_btree, P z1 -> P (Z_bnode z z0 z1))
         -> forall z : Z_btree, P z *)

Print positive.
(* Inductive positive : Set
   := xI : positive -> positive
    | xO : positive -> positive
    | xH : positive *)

Check positive_ind.
(* positive_ind : forall P : positive -> Prop,
   (forall p : positive, P p -> P (p~1))
   -> (forall p : positive, P p -> P (p~0))
   -> P 1 -> forall p : positive, P p *)

Print Z.
(* Inductive Z : Set
   :=  Z0 : Z
    | Zpos : positive -> Z
    | Zneg : positive -> Z *)

Open Scope Z_scope.

Fixpoint sum_all_values (t : Z_btree) : Z
  := match t with
     | Z_leaf => 0
     | Z_bnode x t1 t2 => x + sum_all_values t1 + sum_all_values t2
     end.

Example sum_all_values_ex1 : sum_all_values Z_leaf = 0.
Proof. reflexivity. Qed.

Definition zbtree3 := Z_bnode 1 Z_leaf (Z_bnode 2 Z_leaf Z_leaf).
Example sum_all_values_ex2 : sum_all_values zbtree3 = 3.
Proof. reflexivity. Qed.

(* authors' solution *)
Fixpoint zero_present (t : Z_btree) : bool
  := match t with
     | Z_leaf => false
     | Z_bnode 0 t1 t2 => true
     | Z_bnode _ t1 t2 => zero_present t1 || zero_present t2
     end.

Fixpoint zero_present' (t : Z_btree) : bool
  := match t with
     | Z_leaf => false
     | Z_bnode x t1 t2 => (x =? 0) || zero_present' t1 || zero_present' t2
     end.

Example zero_present_ex1 : zero_present Z_leaf = false.
Proof. reflexivity. Qed.

Example zero_present_ex2 : zero_present zbtree3 = false.
Proof. reflexivity. Qed.

Definition zbtree01 := Z_bnode 0 Z_leaf Z_leaf.
Definition zbtree02 := Z_bnode 1 zbtree3 (Z_bnode 2 zbtree01 zbtree3).

Example zero_present_ex3 : zero_present zbtree01 = true.
Proof. reflexivity. Qed.

Example zero_present_ex4 : zero_present zbtree02 = true.
Proof. reflexivity. Qed.

Theorem zero_present_eq (t : Z_btree) : zero_present t = zero_present' t.
Proof.
  induction t as [| x t1 IH1 t2 IH2]; try reflexivity.
  simpl. rewrite IH1, IH2.
  destruct x as [| x_pos | x_neg]; try reflexivity.
Qed.

Fixpoint add_one (x : positive) : positive
  := match x with
     | xH => (xO xH)
     | xO p => xI p
     | xI p => xO (add_one p)
     end.

Open Scope positive_scope.

Example add_one_ex1 : add_one 1 = 2.
Proof. reflexivity. Qed.

Example add_one_ex2 : add_one 2 = 3.
Proof. reflexivity. Qed.

Example add_one_ex3 : add_one 3 = 4.
Proof. reflexivity. Qed.

Example add_one_ex31 : add_one 31 = 32.
Proof. reflexivity. Qed.

Example add_one_ex32 : add_one 32 = 33.
Proof. reflexivity. Qed.

Example add_one_ex33 : add_one 33 = 34.
Proof. reflexivity. Qed.

(* Exercise 6.19
   What is the representation in the type positive
   for numbers 1000, 25, 512? *)
Example pos25 : 25 = xI (xO (xO (xI xH))).
Proof. reflexivity. Qed.

Example pos512 : 512 = xO (xO (xO (xO (xO (xO (xO (xO (xO xH)))))))).
Proof. reflexivity. Qed.

Example pos1000 : 1000 = xO (xO (xO (xI (xO (xI (xI (xI (xI xH)))))))).
Proof. reflexivity. Qed.

Unset Printing Notations.
Check 1000. (* xO (xO (xO (xI (xO (xI (xI (xI (xI xH)))))))) : positive *)
Set Printing Notations.

(* Exercise 6.20
   Build the function [pos_even_bool] of type [positive -> bool]
   that returns the value [true] exactly when the argument is even. *)
Definition pos_even_bool (x : positive) : bool
  := match x with xO _ => true | _ => false end.

Example pos_even_bool_ex1 : pos_even_bool 1 = false.
Proof. reflexivity. Qed.

Example pos_even_bool_ex2 : pos_even_bool 2 = true.
Proof. reflexivity. Qed.

Example pos_even_bool_ex3 : pos_even_bool 3 = false.
Proof. reflexivity. Qed.

Example pos_even_bool_ex24 : pos_even_bool 24 = true.
Proof. reflexivity. Qed.

Example pos_even_bool_ex31 : pos_even_bool 31 = false.
Proof. reflexivity. Qed.

Lemma xI_is_not_even (x : positive) : Nat.even (Pos.to_nat x~1) = false.
Proof.
  rewrite Pos2Nat.inj_xI, <- Nat.add_1_l, Nat.even_add_mul_2. reflexivity.
Qed.

Theorem pos_even_bool_correct (x : positive)
  : pos_even_bool x = Nat.even (Pos.to_nat x).
Proof.
  destruct x as [p | p |]; try reflexivity.
  - rewrite Pos2Nat.inj_xI, <- Nat.add_1_l.
    rewrite Nat.even_add_mul_2. reflexivity.
  - rewrite Pos2Nat.inj_xO.
    pattern (2 * Pos.to_nat p)%nat. rewrite <- Nat.add_0_l.
    rewrite Nat.even_add_mul_2. reflexivity.
Qed.

(* Exercise 6.21
   Build the function [pos_div4] of type [positive -> Z]
   that maps any number [z] to the integer part of [z/4]. *)
Definition N_div2 (z : N) : N
  := match z with
     | Npos (xI p) | Npos (xO p) => Npos p
     | _ => N0
     end.

Example N_div2_ex0 : N_div2 N0 = N0.
Proof. reflexivity. Qed.

Example N_div2_ex1 : N_div2 1 = N0.
Proof. reflexivity. Qed.

Example N_div2_ex2 : N_div2 2 = 1%N.
Proof. reflexivity. Qed.

Example N_div2_ex3 : N_div2 3 = 1%N.
Proof. reflexivity. Qed.

Example N_div2_ex4 : N_div2 4 = 2%N.
Proof. reflexivity. Qed.

Example N_div2_ex20 : N_div2 20 = 10%N.
Proof. reflexivity. Qed.

Example N_div2_ex21 : N_div2 21 = 10%N.
Proof. reflexivity. Qed.

Theorem N_div2_correct (z : N) : N_div2 z = (z / 2)%N.
Proof.
  rewrite <- N.div2_div.
  destruct z as [| z']; reflexivity.
Qed.

Definition pos_div4 (z : positive) : Z
  := Z.of_N (N_div2 (N_div2 (Npos z))).

Example pos_div4_ex1 : pos_div4 1 = Z0.
Proof. reflexivity. Qed.

Example pos_div4_ex2 : pos_div4 2 = Z0.
Proof. reflexivity. Qed.

Example pos_div4_ex3 : pos_div4 3 = Z0.
Proof. reflexivity. Qed.

Example pos_div4_ex4 : pos_div4 4 = 1%Z.
Proof. reflexivity. Qed.

Example pos_div4_ex5 : pos_div4 5 = 1%Z.
Proof. reflexivity. Qed.

Example pos_div4_ex20 : pos_div4 20 = 5%Z.
Proof. reflexivity. Qed.

Example pos_div4_ex21 : pos_div4 23 = 5%Z.
Proof. reflexivity. Qed.

Definition pos_div4' (z : positive) : Z
  := match z with
     | xI (xI p) | xI (xO p) | xO (xI p) | xO (xO p) => Zpos p
     | _ => Z0
     end.

Theorem pos_div4_eq (z : positive) : pos_div4 z = pos_div4' z.
Proof.
  destruct z as [p | p |]; try reflexivity;
    destruct p as [p' | p' |]; reflexivity.
Qed.

Theorem pos_div4_correct (z : positive) : pos_div4 z = Zpos z / 4.
Proof.
  unfold pos_div4. rewrite 2 N_div2_correct.
  rewrite N.div_div; try discriminate. simpl.
  rewrite N2Z.inj_div. reflexivity.
Qed.

(* Exercise 6.22
   Assuming there exists a function [Pos.mul] t that describes the
   multiplication of two [positive] representations and returns
   a [positive] representation, use this function to build
   a function that multiplies numbers of type [Z]
   and returns a value of type [Z]. *)
Definition Z_mul (x y : Z) : Z
  := match x, y with
     | Z0, _ | _, Z0 => Z0
     | Zpos x', Zpos y' | Zneg x', Zneg y' => Zpos (Pos.mul x' y')
     | Zneg x', Zpos y' | Zpos x', Zneg y' => Zneg (Pos.mul x' y')
     end.

Theorem Z_mul_correct (x y : Z) : Z_mul x y = (x * y)%Z.
Proof. reflexivity. Qed.

(* Exercise 6.23
   Build the inductive type that represents the language of
   propositional logic without variables: *)
Inductive L : Set
  := L_and : L -> L -> L
   | L_or : L -> L -> L
   | L_not : L -> L
   | L_impl : L -> L -> L
   | L_True | L_False.

Check (L_and L_True (L_impl (L_not L_True) L_False)).

Fixpoint L_ev (f : L) : bool
  := match f with
     | L_and x y => (L_ev x) && (L_ev y)
     | L_or x y => (L_ev x) || (L_ev y)
     | L_not x => negb (L_ev x)
     | L_impl x y => implb (L_ev x) (L_ev y)
     | L_True => true
     | L_False => false
     end.

Example L_ev_ex : L_ev (L_and L_True (L_impl (L_not L_True) L_False)) = true.
Proof. reflexivity. Qed.

(* Exercise 6.24 *
   Every strictly positive rational number can be obtained in a
   unique manner by a succession of applications of functions N and D on the
   number one, where N and D are defined by the following equations:
   N(x) = 1 + x
   D(x) = 1 / (1 + 1/x)
   We can associate any strictly positive rational number with an element of
   an inductive type with one constructor for one, and two other constructors
   representing the functions N and D. Define this inductive type
   (see the related exercise 6.44). *)
Inductive F : Set
  := one : F (* 1 *)
   | n : F -> F (* 1 + f *)
   | d : F -> F (* 1 / (1 + (1 / f)) *)
.

(* Exercise 6.25
   Define a function [value_present] with the type
   [value_present : Z -> Z_btree -> bool]
   that determines whether an integer appears in a binary tree. *)
Fixpoint value_present (z : Z) (t : Z_btree) {struct t} : bool
  := match t with
     | Z_leaf => false
     | Z_bnode x t1 t2 => (x =? z)%Z || value_present z t1 || value_present z t2
     end.

(* Exercise 6.26
   Define a function [power: Z -> nat -> Z] to compute
   the power of an integer and
   a function [discrete_log : positive -> nat] that maps
   any number [p] to the number [n] such that 2^n <= p < 2^(n+1). *)
Fixpoint power (z : Z) (n : nat) {struct n} : Z
  := match n with
     | O => 1
     | S p => z * power z p
     end.

Example power_ex1 : power 3 3 = 27%Z.
Proof. reflexivity. Qed.

Theorem two_power_is_power (n : nat) : Z.of_nat (two_power n) = power 2 n.
Proof.
  rewrite two_power_eq.
  induction n as [| p IH]; try reflexivity.
  cbv delta [two_power' power] beta iota.
  fold two_power' power.
  rewrite Nat2Z.inj_mul. rewrite IH. reflexivity.
Qed.

Theorem power_correct (z : Z) (n : nat) : power z n = Zpower_nat z n.
Proof.
  induction n as [| p IH]; try reflexivity.
  simpl. rewrite IH. reflexivity.
Qed.

Fixpoint discrete_log (z : positive) : nat
  := match z with
     | xH => O
     | xO p | xI p => S (discrete_log p)
     end.

Example discrete_log_ex1 : discrete_log 1 = 0%nat.
Proof. reflexivity. Qed.

Example discrete_log_ex2 : discrete_log 2 = 1%nat.
Proof. reflexivity. Qed.

Example discrete_log_ex3 : discrete_log 3 = 1%nat.
Proof. reflexivity. Qed.

Example discrete_log_ex4 : discrete_log 4 = 2%nat.
Proof. reflexivity. Qed.

Example discrete_log_ex5 : discrete_log 5 = 2%nat.
Proof. reflexivity. Qed.

Example discrete_log_ex7 : discrete_log 7 = 2%nat.
Proof. reflexivity. Qed.

Example discrete_log_ex8 : discrete_log 8 = 3%nat.
Proof. reflexivity. Qed.

Lemma pos_le_shift (x y : positive) : x <= y -> x~0 <= y~1.
Proof.
  intro H. unfold Pos.le, Pos.compare. simpl.
  apply Pos.compare_cont_Lt_not_Gt. assumption.
Qed.

Lemma pos_lt_shift (y z : positive) : y < z -> y~1 < z~0.
Proof.
  intro H. unfold Pos.lt, Pos.compare. simpl.
  apply Pos.compare_cont_Gt_Lt. assumption.
Qed.

Lemma pos_le_lt_shift (x y z : positive) : x <= y < z -> x~0 <= y~0 < z~0.
Proof.
  intros [Hle Hlt].
  split; [unfold Pos.le | unfold Pos.lt]; unfold Pos.compare; simpl;
    fold Pos.compare; assumption.
Qed.

Lemma pos_le_lt_shift' (x y z : positive) : x <= y < z -> x~0 <= y~1 < z~0.
Proof.
  intros [Hle Hlt].
  split; [apply pos_le_shift | apply pos_lt_shift]; assumption.
Qed.

Theorem discrete_log_correct (z : positive) (n : nat)
  : discrete_log z = n -> shift_nat n 1 <= z < shift_nat (n + 1) 1.
Proof.
  generalize dependent n.
  induction z as [p IH | p IH |]; simpl; intros n H.
  - destruct n as [| n']; try discriminate H.
    apply Nat.succ_inj in H. simpl.
    apply pos_le_lt_shift', IH, H.
  - destruct n as [| n']; try discriminate H.
    apply Nat.succ_inj in H. simpl.
    apply pos_le_lt_shift, IH, H.
  - subst n. simpl. unfold Pos.le, Pos.lt, Pos.compare.
    simpl. split; [discriminate | reflexivity].
Qed.

(* 6.3.5 ** Types with Functional Fields *)
Inductive Z_fbtree : Set
  := Z_fleaf : Z_fbtree
   | Z_fnode : Z -> (bool -> Z_fbtree) -> Z_fbtree.

Definition right_son (t : Z_btree) : Z_btree
  := match t with
     | Z_leaf => Z_leaf
     | Z_bnode a t1 t2 => t2
     end.

Definition fright_son (t : Z_fbtree) : Z_fbtree
  := match t with
     | Z_fleaf => Z_fleaf
     | Z_fnode a f => f false
     end.

Check Z_fbtree_ind.
(* Z_fbtree_ind : forall P : Z_fbtree -> Prop,
   P Z_fleaf
   -> (forall (z : Z) (z0 : bool -> Z_fbtree),
        (forall b : bool, P (z0 b)) -> P (Z_fnode z z0))
   -> forall z : Z_fbtree, P z *)

(* let's convert one tree to another *)
Fixpoint Z_btree_to_fbtree (t : Z_btree) : Z_fbtree
  := match t with
     | Z_leaf => Z_fleaf
     | Z_bnode z t1 t2
       => Z_fnode z (fun b : bool => Z_btree_to_fbtree (if b then t1 else t2))
     end.

Fixpoint Z_fbtree_to_btree (t : Z_fbtree) : Z_btree
  := match t with
     | Z_fleaf => Z_leaf
     | Z_fnode z f => Z_bnode z
                              (Z_fbtree_to_btree (f true))
                              (Z_fbtree_to_btree (f false))
     end.

(* proove that this functions are bijective *)
Theorem Z_btree_to_fbtree_to_btree_is_id (t : Z_btree)
  : Z_fbtree_to_btree (Z_btree_to_fbtree t) = t.
Proof.
  induction t as [| z t1 IH1 t2 IH2]; try reflexivity.
  simpl. rewrite IH1, IH2. reflexivity.
Qed.

Require Import FunctionalExtensionality.

Theorem Z_fbtree_to_btree_to_fbtree_is_id (t : Z_fbtree)
  : Z_btree_to_fbtree (Z_fbtree_to_btree t) = t.
Proof.
  induction t as [| z f IH]; try reflexivity.
  simpl. f_equal. extensionality b.
  destruct b; rewrite IH; reflexivity.
Qed.
(* return to the book *)

Fixpoint fsum_all_values (t : Z_fbtree) : Z
  := match t with
     | Z_fleaf => 0
     | Z_fnode z f => z + fsum_all_values (f true) + fsum_all_values (f false)
     end.

(* Exercise 6.27
   Define a function [fzero_present : Z_fbtree -> bool] that maps
   any tree x to true if and only if x contains the value zero. *)
Fixpoint fzero_present (t : Z_fbtree) : bool
  := match t with
     | Z_fleaf => false
     | Z_fnode z f => (z =? 0)%Z || fzero_present (f true) || fzero_present (f false)
     end.

Definition fzero_present' (t : Z_fbtree) : bool
  := zero_present' (Z_fbtree_to_btree t).

Theorem fzero_present_eq (t : Z_fbtree) : fzero_present t = fzero_present' t.
Proof.
  induction t as [| z f IH]; try reflexivity.
  unfold fzero_present'. simpl. rewrite !IH. reflexivity.
Qed.

(* 6.3.5.2 *** Infinitely Branching Trees *)
Inductive Z_inf_branch_tree : Set
  := Z_inf_leaf : Z_inf_branch_tree
   | Z_inf_node : Z -> (nat -> Z_inf_branch_tree) -> Z_inf_branch_tree.

Fixpoint n_sum_all_values (n : nat) (t : Z_inf_branch_tree) : Z
  := match t with
     | Z_inf_leaf => Z0
     | Z_inf_node z f
       => z + sum_f n (fun x : nat => n_sum_all_values n (f x))
     end.

(* Exercise 6.28 **
   Define a function that checks whether the zero value occurs
   in an infinitely branching tree at a node reachable only
   by indices smaller than a number n. *)

(* authors' solution (fixed) *)
Fixpoint any_true (n : nat) (f : nat -> bool) {struct n} : bool
  := match n with
     | O => false
     | S p => orb (f p) (any_true p f)
     end.

Fixpoint izero_present (n : nat) (t : Z_inf_branch_tree) {struct t} : bool
  := match t with
     | Z_inf_leaf => false
     | Z_inf_node v f
       => match v with
          | Z0 => true
          | _ => any_true n (fun p => izero_present n (f p))
          end
     end.

(* My solution *)
(* do map and reduce (foldl) in one on natural range (from 0 to n, excluding n) *)
Fixpoint mr_range {A : Type} (n : nat) (f : nat -> A)
         (r : A -> A -> A) (a0 : A) {struct n}
  := match n with
     | O => a0
     | S n' => r (mr_range n' f r a0) (f n')
     end.

Definition sum_f' (n : nat) (f : nat -> Z) := mr_range n f Z.add Z0.
Theorem sum_f_eq (n : nat) (f : nat -> Z) : sum_f n f = sum_f' n f.
Proof.
  unfold sum_f'. induction n as [| n' IH]; try reflexivity.
  simpl. rewrite <- IH, Z.add_comm. reflexivity.
Qed.

Definition any_true' (n : nat) (f : nat -> bool) : bool := mr_range n f orb false.
Theorem any_true_eq (n : nat) (f : nat -> bool) : any_true n f = any_true' n f.
Proof.
  unfold any_true'. induction n as [| n' IH]; try reflexivity.
  simpl. rewrite <- IH, orb_comm. reflexivity.
Qed.

Fixpoint inf_zero_present (n : nat) (t : Z_inf_branch_tree) {struct t} : bool
  := match t with
     | Z_inf_leaf => false
     | Z_inf_node z f => (z =? 0)%Z
                         || mr_range n (compose (inf_zero_present n) f) orb false
     end.

Theorem inf_zero_present_eq (n : nat) (t : Z_inf_branch_tree)
  : izero_present n t = inf_zero_present n t.
Proof.
  induction t as [| z f IH]; try reflexivity.
  simpl. rewrite any_true_eq. unfold any_true', compose.
  destruct z as [| z' | z'] eqn:H; try reflexivity;
    simpl; f_equal; extensionality k; apply IH.
Qed.
