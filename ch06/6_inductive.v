Require Export ZArith List Arith Bool.

Inductive month : Set
  := January | February | March | April | May | June
     | July | August | September | October | November | December.

(* Exercise 6.1
   Define an inductive type for seasons and then use the function
   [month_rec] to define a function that maps every month to the season that
   contains most of its days. *)
Inductive season : Set := Winter | Spring | Summer | Fall.

Check season_rec.
(* season_rec : forall P : season -> Set,
   P Winter -> P Spring -> P Summer -> P Fall
   -> forall s : season, P s *)

Definition is_winter : season -> bool.
  intro s. apply season_rec.
  - (* Winter *) exact true.
  - (* Spring *) exact false.
  - (* Summer *) exact false.
  - (* Fall   *) exact false.
  - exact s.
Defined.

Print is_winter.
(* is_winter : season -> bool
   := fun s : season
      => season_rec (fun _ : season => bool) true false false false s *)

Compute (is_winter Winter). (* = true : bool *)
Compute (is_winter Fall). (* = false : bool *)

Definition season_of_month : month -> season
  := month_rec (fun _ : month => season)
               Winter Winter
               Spring Spring Spring
               Summer Summer Summer
               Fall Fall Fall
               Winter.

Compute (season_of_month December). (* = Winter : season *)
Compute (season_of_month July). (* = Summer : season *)

(* Exercise 6.2
   What are the types of [bool_ind] and [bool_rec] that are
   generated by the Coq system for the type bool? *)
Check bool_ind.
(* bool_ind : forall P : bool -> Prop,
     P true -> P false -> forall b : bool, P b *)

(* 6.1.2 Simple Reasoning and Computing *)
Theorem month_equal (m : month)
 : m=January \/ m=February \/ m=March \/ m=April \/ m=May \/ m=June
   \/ m=July \/ m=August \/  m=September \/ m=October \/ m=November
   \/ m=December.
Proof. destruct m; auto 12. Qed.

(** explicit use of month_ind: *)
Theorem month_equal' (m : month)
 : m=January \/ m=February \/ m=March \/ m=April
   \/ m=May \/ m=June \/ m=July \/ m=August
   \/ m=September \/ m=October \/ m=November \/ m=December.
Proof. pattern m. apply month_ind; auto 12. Qed.

(* Exercise 6.3 Prove in two different ways the following theorem:
   1. Give directly a proof term, with occurences of
      bool_ind, or_introl, or_intror and refl_equal.
   2. Use the following tactics :
      pattern, apply, left, right, and reflexivity. *)
Theorem bool_cases (b : bool) : b = true \/ b = false.
Proof.
  exact (bool_ind (fun c => c = true \/ c = false)
                  (or_introl eq_refl)
                  (or_intror eq_refl) b).
Qed.

Theorem bool_cases' (b : bool) : b = true \/ b = false.
Proof. pattern b. apply bool_ind; [left | right]; reflexivity. Qed.

Theorem bool_cases'' (b : bool) : b = true \/ b = false.
Proof. destruct b; [left | right]; reflexivity. Qed.

(* 6.1.4 Pattern Matching *)
Check (fun b : bool => match b with false => 45 | true => 33 end).
(* fun b : bool => if b then 33 else 45 : bool -> nat *)

Definition month_length (leap : bool) (m : month) : nat
  := match m with
     | January => 31 | February => if leap then 29 else 28
     | March => 31   | April => 30    | May => 31  | June => 30
     | July => 31    | August => 31   | September => 30
     | October => 31 | November => 30 | December => 31
     end.

Definition month_length' (leap : bool)
  := month_rec (fun _ : month => nat)
               31 (if leap then 29 else 28)
               31 30 31 30 31 31 30 31 30 31.

Definition month_length'' (leap : bool) (m : month)
  := match m with
     | February => if leap then 29 else 28
     | April  | June  | September | November => 30
     | _  => 31
     end.

Example month_length_eq1 : month_length = month_length'.
Proof. reflexivity. Qed.

Example month_length_eq2 : month_length = month_length''.
Proof. reflexivity. Qed.

Eval compute in (fun leap => month_length leap November).
(* = fun _ : bool => 30 : bool -> nat *)

Example length_february : month_length false February = 28.
Proof. reflexivity. Qed.

(* Exercise 6.4
   Using the type introduced for seasons in Exercise 6.1 page 139,
   write the function that maps any month to the season
   that contains most of its days, this time
   using the pattern matching construct. *)

Definition season_of_month' (m : month) : season
  := match m with
     | December | January | February => Winter
     | March | April | May => Spring
     | June | July | August => Summer
     | September | October | November => Fall
     end.

Example season_of_month_eq : season_of_month = season_of_month'.
Proof. reflexivity. Qed.

(* Exercise 6.5
   Write the function that maps every month that has an even
   number of days to the boolean value true and the others to false. *)
Definition is_even_days_in_month (leap : bool) (m : month)
  := Nat.even (month_length leap m).

(* Exercise 6.6
   Define the functions associated with the following boolean connectives:
   Notice that these functions are already defined in the standard library
   under the names negb, orb, andb, xorb and Bool.eqb. *)
Definition bool_not (b : bool) : bool := if b then false else true.
Definition bool_or (a b : bool) : bool
  := if a then true else
       if b then true else false.
Definition bool_and (a b : bool) : bool := if a then b else false.
Definition bool_xor (a b : bool) : bool
  := if a then bool_not b else b.
Definition bool_eq (a b : bool) : bool
  := if a then b else bool_not b.

(* Prove the following theorems: *)
Theorem bool_xor_not_eq (b1 b2 : bool)
  : bool_xor b1 b2 = bool_not (bool_eq b1 b2).
Proof. destruct b1, b2; reflexivity. Qed.

Theorem bool_not_and (b1 b2 : bool)
  : bool_not (bool_and b1 b2) = bool_or (bool_not b1) (bool_not b2).
Proof. destruct b1, b2; reflexivity. Qed.

Theorem bool_not_not (b : bool) : bool_not (bool_not b) = b.
Proof. destruct b; reflexivity. Qed.

Theorem bool_tex (b : bool) : bool_or b (bool_not b) = true.
Proof. destruct b; reflexivity. Qed.

Theorem bool_eq_reflect (b1 b2 : bool) : bool_eq b1 b2 = true -> b1 = b2.
Proof.
  destruct b1, b2; simpl; intro H;
    try rewrite H; reflexivity.
Qed.

Theorem bool_eq_reflect2 (b1 b2 : bool) : b1 = b2 -> bool_eq b1 b2 = true.
Proof. intro H. subst b2. destruct b1; reflexivity. Qed.

Theorem bool_not_or (b1 b2 : bool)
  : bool_not (bool_or b1 b2) = bool_and (bool_not b1) (bool_not b2).
Proof. destruct b1, b2; reflexivity. Qed.

Theorem bool_or_and_distr (b1 b2 b3 : bool)
  : bool_or (bool_and b1 b3) (bool_and b2 b3) = bool_and (bool_or b1 b2) b3.
Proof. destruct b1, b2, b3; reflexivity. Qed.

(* 6.1.5 Record Types *)
Open Scope Z_scope.

Inductive plane : Set := point : Z -> Z -> plane.
(*
plane is defined
plane_rect is defined
plane_ind is defined
plane_rec is defined
plane_sind is defined
*)

Check point. (* point : Z -> Z -> plane *)
Check plane_ind.
(* plane_ind : forall P : plane -> Prop,
   (forall z z0 : Z, P (point z z0)) -> forall p : plane, P p *)

Definition abscissa (p : plane) : Z
  := match p with point x y => x end.
Check abscissa. (* abscissa : plane -> Z *)

Reset plane. (* also reset [abscissa] *)

Record plane : Set := point {abscissa : Z; ordinate : Z}.
(*
plane is defined
abscissa is defined
ordinate is defined
*)
Print plane.
(* Record plane : Set := point { abscissa : Z;  ordinate : Z } *)
Check point. (* point : Z -> Z -> plane *)
Check abscissa. (* abscissa : plane -> Z *)
Print abscissa.
(* abscissa : plane -> Z
   := fun p : plane => let (abscissa, _) := p in abscissa *)

(* Exercise 6.7 What is the type of plane_rec? *)
(* Check plane_rec. *)
(* Error: The reference plane_rec was not found in the current environment. *)

(* Exercise 6.8
   Define a function that computes the "Manhattan" distance for
   points of the plane (the Manhattan distance
   is the sum of the absolute values of differences of coordinates). *)
Definition manhattan_distance (p1 p2 : plane) : Z
  := let (x1, y1) := p1 in
     let (x2, y2) := p2 in
     Z.abs (x1 - x2) + Z.abs (y1 - y2).

Check (point 1 2).
Check (point 1 (-2)).

Example manhattan_distance_ex
  : manhattan_distance (point (-1) (-2)) (point 4 2) = 9.
Proof. reflexivity. Qed.

(* 6.1.6 Records with Variants *)
Inductive vehicle : Set
  := bicycle (* [number of seats] *) : nat -> vehicle
   | motorized (* [number of seats, number of wheels] *)
     : nat -> nat -> vehicle.

Check vehicle_ind.
(* vehicle_ind : forall P : vehicle -> Prop,
   (forall n : nat, P (bicycle n)) ->
   (forall n n0 : nat, P (motorized n n0)) -> forall v : vehicle, P v *)

Definition nb_seats (v : vehicle) : nat
  := match v with
     | bicycle n => n
     | motorized n _ => n
     end.

Definition nb_wheels (v : vehicle) : nat
  := match v with
     | bicycle _ => 2
     | motorized _ m => m
     end.

(* Exercise 6.9
   What is the type of [vehicle_rec]? Use this function to define
   an equivalent to [nb_seats]. *)
Check vehicle_rec.
(* vehicle_rec : forall P : vehicle -> Set,
   (forall n : nat, P (bicycle n)) ->
   (forall n n0 : nat, P (motorized n n0)) -> forall v : vehicle, P v *)

Definition nb_seats' : vehicle -> nat
  := vehicle_rec (fun _ : vehicle => nat)
                 (fun n => n)
                 (fun n _ => n).

Example nb_seats_eq : nb_seats = nb_seats'.
Proof. reflexivity. Qed.
